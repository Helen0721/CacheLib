/**
 * Autogenerated by Thrift for /disk/CacheLib/cachelib/external/fbthrift/thrift/lib/thrift/standard.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>


#include <folly/io/IOBuf.h>
#include <folly/FBString.h>

namespace apache {
namespace thrift {
namespace ident {
struct uri;
struct typeHashPrefixSha2_256;
struct scopedName;
struct boolType;
struct byteType;
struct i16Type;
struct i32Type;
struct i64Type;
struct floatType;
struct doubleType;
struct stringType;
struct binaryType;
struct enumType;
struct typedefType;
struct structType;
struct unionType;
struct exceptionType;
struct listType;
struct setType;
struct mapType;
} // namespace ident
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_uri
#define APACHE_THRIFT_ACCESSOR_uri
APACHE_THRIFT_DEFINE_ACCESSOR(uri);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_typeHashPrefixSha2_256
#define APACHE_THRIFT_ACCESSOR_typeHashPrefixSha2_256
APACHE_THRIFT_DEFINE_ACCESSOR(typeHashPrefixSha2_256);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_scopedName
#define APACHE_THRIFT_ACCESSOR_scopedName
APACHE_THRIFT_DEFINE_ACCESSOR(scopedName);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_boolType
#define APACHE_THRIFT_ACCESSOR_boolType
APACHE_THRIFT_DEFINE_ACCESSOR(boolType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_byteType
#define APACHE_THRIFT_ACCESSOR_byteType
APACHE_THRIFT_DEFINE_ACCESSOR(byteType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_i16Type
#define APACHE_THRIFT_ACCESSOR_i16Type
APACHE_THRIFT_DEFINE_ACCESSOR(i16Type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_i32Type
#define APACHE_THRIFT_ACCESSOR_i32Type
APACHE_THRIFT_DEFINE_ACCESSOR(i32Type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_i64Type
#define APACHE_THRIFT_ACCESSOR_i64Type
APACHE_THRIFT_DEFINE_ACCESSOR(i64Type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_floatType
#define APACHE_THRIFT_ACCESSOR_floatType
APACHE_THRIFT_DEFINE_ACCESSOR(floatType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_doubleType
#define APACHE_THRIFT_ACCESSOR_doubleType
APACHE_THRIFT_DEFINE_ACCESSOR(doubleType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stringType
#define APACHE_THRIFT_ACCESSOR_stringType
APACHE_THRIFT_DEFINE_ACCESSOR(stringType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_binaryType
#define APACHE_THRIFT_ACCESSOR_binaryType
APACHE_THRIFT_DEFINE_ACCESSOR(binaryType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_enumType
#define APACHE_THRIFT_ACCESSOR_enumType
APACHE_THRIFT_DEFINE_ACCESSOR(enumType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_typedefType
#define APACHE_THRIFT_ACCESSOR_typedefType
APACHE_THRIFT_DEFINE_ACCESSOR(typedefType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_structType
#define APACHE_THRIFT_ACCESSOR_structType
APACHE_THRIFT_DEFINE_ACCESSOR(structType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_unionType
#define APACHE_THRIFT_ACCESSOR_unionType
APACHE_THRIFT_DEFINE_ACCESSOR(unionType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_exceptionType
#define APACHE_THRIFT_ACCESSOR_exceptionType
APACHE_THRIFT_DEFINE_ACCESSOR(exceptionType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_listType
#define APACHE_THRIFT_ACCESSOR_listType
APACHE_THRIFT_DEFINE_ACCESSOR(listType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_setType
#define APACHE_THRIFT_ACCESSOR_setType
APACHE_THRIFT_DEFINE_ACCESSOR(setType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_mapType
#define APACHE_THRIFT_ACCESSOR_mapType
APACHE_THRIFT_DEFINE_ACCESSOR(mapType);
#endif
} // namespace detail
} // namespace thrift
} // namespace apache

// BEGIN declare_enums
namespace apache::thrift::type {

enum class Void {
  Unused = 0,
};



enum class StandardProtocol {
  Custom = 0,
  Binary = 1,
  Compact = 2,
  Json = 3,
  SimpleJson = 4,
};



} // namespace apache::thrift::type

namespace std {
template<> struct hash<::apache::thrift::type::Void> :
  ::apache::thrift::detail::enum_hash<::apache::thrift::type::Void> {};
template<> struct hash<::apache::thrift::type::StandardProtocol> :
  ::apache::thrift::detail::enum_hash<::apache::thrift::type::StandardProtocol> {};
} // std

namespace apache { namespace thrift {


template <> struct TEnumDataStorage<::apache::thrift::type::Void>;

template <> struct TEnumTraits<::apache::thrift::type::Void> {
  using type = ::apache::thrift::type::Void;

  static constexpr std::size_t const size = 1;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }
  static constexpr type min() { return type::Unused; }
  static constexpr type max() { return type::Unused; }
};


template <> struct TEnumDataStorage<::apache::thrift::type::StandardProtocol>;

template <> struct TEnumTraits<::apache::thrift::type::StandardProtocol> {
  using type = ::apache::thrift::type::StandardProtocol;

  static constexpr std::size_t const size = 5;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }
  static constexpr type min() { return type::Custom; }
  static constexpr type max() { return type::SimpleJson; }
};


}} // apache::thrift


// END declare_enums
// BEGIN forward_declare
namespace apache::thrift::type {
class TypeUri;
class TypeName;
} // namespace apache::thrift::type
// END forward_declare
namespace apache::thrift::detail::annotation {
} // namespace apache::thrift::detail::annotation

namespace apache::thrift::detail::qualifier {
} // namespace apache::thrift::detail::qualifier

// BEGIN hash_and_equal_to
// END hash_and_equal_to
namespace apache::thrift::type {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

typedef folly::fbstring ByteString;
typedef folly::IOBuf ByteBuffer;

class TypeUri final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const char* __fbthrift_thrift_uri();
  static std::string_view __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static std::string_view __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
    ::apache::thrift::ident::uri,
    ::apache::thrift::ident::typeHashPrefixSha2_256,
    ::apache::thrift::ident::scopedName
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0,1,2,3};
  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::string_t,
    ::apache::thrift::type::cpp_type<folly::fbstring, ::apache::thrift::type::binary_t>,
    ::apache::thrift::type::string_t
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 3;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_destruct();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = TypeUri;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    uri = 1,
    typeHashPrefixSha2_256 = 2,
    scopedName = 3,
  } ;

  TypeUri()
      : type_(folly::to_underlying(Type::__EMPTY__)) {}

  TypeUri(TypeUri&& rhs) noexcept
      : type_(folly::to_underlying(Type::__EMPTY__)) {
    if (this == &rhs) { return; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        return;
      }
      case Type::uri:
      {
        set_uri(std::move(rhs.value_.uri));
        break;
      }
      case Type::typeHashPrefixSha2_256:
      {
        set_typeHashPrefixSha2_256(std::move(rhs.value_.typeHashPrefixSha2_256));
        break;
      }
      case Type::scopedName:
      {
        set_scopedName(std::move(rhs.value_.scopedName));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    apache::thrift::clear(rhs);
  }

  TypeUri(const TypeUri& rhs);

  TypeUri& operator=(TypeUri&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        __fbthrift_clear();
        return *this;
      }
      case Type::uri:
      {
        set_uri(std::move(rhs.value_.uri));
        break;
      }
      case Type::typeHashPrefixSha2_256:
      {
        set_typeHashPrefixSha2_256(std::move(rhs.value_.typeHashPrefixSha2_256));
        break;
      }
      case Type::scopedName:
      {
        set_scopedName(std::move(rhs.value_.scopedName));
        break;
      }
      default:
      {
        assert(false);
        __fbthrift_clear();
      }
    }
    apache::thrift::clear(rhs);
    return *this;
  }

  TypeUri& operator=(const TypeUri& rhs);

  ~TypeUri();

  union storage_type {
    ::std::string uri;
    ::apache::thrift::type::ByteString typeHashPrefixSha2_256;
    ::std::string scopedName;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const TypeUri&) const;
  bool operator<(const TypeUri&) const;

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_uri(::std::string const &t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::uri);
    ::new (std::addressof(value_.uri)) T(t);
    return value_.uri;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_uri(::std::string&& t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::uri);
    ::new (std::addressof(value_.uri)) T(std::move(t));
    return value_.uri;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_uri(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::uri);
    ::new (std::addressof(value_.uri)) ::std::string(std::forward<T>(t)...);
    return value_.uri;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::ByteString& set_typeHashPrefixSha2_256(::apache::thrift::type::ByteString const &t) {
    using T0 = ::apache::thrift::type::ByteString;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::typeHashPrefixSha2_256);
    ::new (std::addressof(value_.typeHashPrefixSha2_256)) T(t);
    return value_.typeHashPrefixSha2_256;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::ByteString& set_typeHashPrefixSha2_256(::apache::thrift::type::ByteString&& t) {
    using T0 = ::apache::thrift::type::ByteString;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::typeHashPrefixSha2_256);
    ::new (std::addressof(value_.typeHashPrefixSha2_256)) T(std::move(t));
    return value_.typeHashPrefixSha2_256;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::type::ByteString, T...>> ::apache::thrift::type::ByteString& set_typeHashPrefixSha2_256(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::typeHashPrefixSha2_256);
    ::new (std::addressof(value_.typeHashPrefixSha2_256)) ::apache::thrift::type::ByteString(std::forward<T>(t)...);
    return value_.typeHashPrefixSha2_256;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_scopedName(::std::string const &t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::scopedName);
    ::new (std::addressof(value_.scopedName)) T(t);
    return value_.scopedName;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_scopedName(::std::string&& t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::scopedName);
    ::new (std::addressof(value_.scopedName)) T(std::move(t));
    return value_.scopedName;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_scopedName(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::scopedName);
    ::new (std::addressof(value_.scopedName)) ::std::string(std::forward<T>(t)...);
    return value_.scopedName;
  }


  ::std::string const& get_uri() const {
    if (getType() != Type::uri) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.uri;
  }

  ::apache::thrift::type::ByteString const& get_typeHashPrefixSha2_256() const {
    if (getType() != Type::typeHashPrefixSha2_256) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.typeHashPrefixSha2_256;
  }

  ::std::string const& get_scopedName() const {
    if (getType() != Type::scopedName) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.scopedName;
  }

  ::std::string& mutable_uri() {
    assert(getType() == Type::uri);
    return value_.uri;
  }

  ::apache::thrift::type::ByteString& mutable_typeHashPrefixSha2_256() {
    assert(getType() == Type::typeHashPrefixSha2_256);
    return value_.typeHashPrefixSha2_256;
  }

  ::std::string& mutable_scopedName() {
    assert(getType() == Type::scopedName);
    return value_.scopedName;
  }

  ::std::string move_uri() {
    assert(getType() == Type::uri);
    return std::move(value_.uri);
  }

  ::apache::thrift::type::ByteString move_typeHashPrefixSha2_256() {
    assert(getType() == Type::typeHashPrefixSha2_256);
    return std::move(value_.typeHashPrefixSha2_256);
  }

  ::std::string move_scopedName() {
    assert(getType() == Type::scopedName);
    return std::move(value_.scopedName);
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> uri_ref() const& {
    return {value_.uri, type_, folly::to_underlying(Type::uri), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> uri_ref() const&& {
    return {std::move(value_.uri), type_, folly::to_underlying(Type::uri), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> uri_ref() & {
    return {value_.uri, type_, folly::to_underlying(Type::uri), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> uri_ref() && {
    return {std::move(value_.uri), type_, folly::to_underlying(Type::uri), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::type::ByteString>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> typeHashPrefixSha2_256_ref() const& {
    return {value_.typeHashPrefixSha2_256, type_, folly::to_underlying(Type::typeHashPrefixSha2_256), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::ByteString>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> typeHashPrefixSha2_256_ref() const&& {
    return {std::move(value_.typeHashPrefixSha2_256), type_, folly::to_underlying(Type::typeHashPrefixSha2_256), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::ByteString>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> typeHashPrefixSha2_256_ref() & {
    return {value_.typeHashPrefixSha2_256, type_, folly::to_underlying(Type::typeHashPrefixSha2_256), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::ByteString>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> typeHashPrefixSha2_256_ref() && {
    return {std::move(value_.typeHashPrefixSha2_256), type_, folly::to_underlying(Type::typeHashPrefixSha2_256), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> scopedName_ref() const& {
    return {value_.scopedName, type_, folly::to_underlying(Type::scopedName), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> scopedName_ref() const&& {
    return {std::move(value_.scopedName), type_, folly::to_underlying(Type::scopedName), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> scopedName_ref() & {
    return {value_.scopedName, type_, folly::to_underlying(Type::scopedName), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> scopedName_ref() && {
    return {std::move(value_.scopedName), type_, folly::to_underlying(Type::scopedName), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<TypeUri>;
  friend void swap(TypeUri& a, TypeUri& b);
};

template <class Protocol_>
unsigned long TypeUri::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


class TypeName final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const char* __fbthrift_thrift_uri();
  static std::string_view __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static std::string_view __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
    ::apache::thrift::ident::boolType,
    ::apache::thrift::ident::byteType,
    ::apache::thrift::ident::i16Type,
    ::apache::thrift::ident::i32Type,
    ::apache::thrift::ident::i64Type,
    ::apache::thrift::ident::floatType,
    ::apache::thrift::ident::doubleType,
    ::apache::thrift::ident::stringType,
    ::apache::thrift::ident::binaryType,
    ::apache::thrift::ident::enumType,
    ::apache::thrift::ident::typedefType,
    ::apache::thrift::ident::structType,
    ::apache::thrift::ident::unionType,
    ::apache::thrift::ident::exceptionType,
    ::apache::thrift::ident::listType,
    ::apache::thrift::ident::setType,
    ::apache::thrift::ident::mapType
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0,1,2,3,4,5,6,7,8,9,10,17,11,12,13,14,15,16};
  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::enum_t<::apache::thrift::type::Void>,
    ::apache::thrift::type::enum_t<::apache::thrift::type::Void>,
    ::apache::thrift::type::enum_t<::apache::thrift::type::Void>,
    ::apache::thrift::type::enum_t<::apache::thrift::type::Void>,
    ::apache::thrift::type::enum_t<::apache::thrift::type::Void>,
    ::apache::thrift::type::enum_t<::apache::thrift::type::Void>,
    ::apache::thrift::type::enum_t<::apache::thrift::type::Void>,
    ::apache::thrift::type::enum_t<::apache::thrift::type::Void>,
    ::apache::thrift::type::enum_t<::apache::thrift::type::Void>,
    ::apache::thrift::type::union_t<::apache::thrift::type::TypeUri>,
    ::apache::thrift::type::union_t<::apache::thrift::type::TypeUri>,
    ::apache::thrift::type::union_t<::apache::thrift::type::TypeUri>,
    ::apache::thrift::type::union_t<::apache::thrift::type::TypeUri>,
    ::apache::thrift::type::union_t<::apache::thrift::type::TypeUri>,
    ::apache::thrift::type::enum_t<::apache::thrift::type::Void>,
    ::apache::thrift::type::enum_t<::apache::thrift::type::Void>,
    ::apache::thrift::type::enum_t<::apache::thrift::type::Void>
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 17;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_destruct();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = TypeName;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    boolType = 1,
    byteType = 2,
    i16Type = 3,
    i32Type = 4,
    i64Type = 5,
    floatType = 6,
    doubleType = 7,
    stringType = 8,
    binaryType = 9,
    enumType = 10,
    typedefType = 17,
    structType = 11,
    unionType = 12,
    exceptionType = 13,
    listType = 14,
    setType = 15,
    mapType = 16,
  } ;

  TypeName()
      : type_(folly::to_underlying(Type::__EMPTY__)) {}

  TypeName(TypeName&& rhs) noexcept
      : type_(folly::to_underlying(Type::__EMPTY__)) {
    if (this == &rhs) { return; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        return;
      }
      case Type::boolType:
      {
        set_boolType(std::move(rhs.value_.boolType));
        break;
      }
      case Type::byteType:
      {
        set_byteType(std::move(rhs.value_.byteType));
        break;
      }
      case Type::i16Type:
      {
        set_i16Type(std::move(rhs.value_.i16Type));
        break;
      }
      case Type::i32Type:
      {
        set_i32Type(std::move(rhs.value_.i32Type));
        break;
      }
      case Type::i64Type:
      {
        set_i64Type(std::move(rhs.value_.i64Type));
        break;
      }
      case Type::floatType:
      {
        set_floatType(std::move(rhs.value_.floatType));
        break;
      }
      case Type::doubleType:
      {
        set_doubleType(std::move(rhs.value_.doubleType));
        break;
      }
      case Type::stringType:
      {
        set_stringType(std::move(rhs.value_.stringType));
        break;
      }
      case Type::binaryType:
      {
        set_binaryType(std::move(rhs.value_.binaryType));
        break;
      }
      case Type::enumType:
      {
        set_enumType(std::move(rhs.value_.enumType));
        break;
      }
      case Type::typedefType:
      {
        set_typedefType(std::move(rhs.value_.typedefType));
        break;
      }
      case Type::structType:
      {
        set_structType(std::move(rhs.value_.structType));
        break;
      }
      case Type::unionType:
      {
        set_unionType(std::move(rhs.value_.unionType));
        break;
      }
      case Type::exceptionType:
      {
        set_exceptionType(std::move(rhs.value_.exceptionType));
        break;
      }
      case Type::listType:
      {
        set_listType(std::move(rhs.value_.listType));
        break;
      }
      case Type::setType:
      {
        set_setType(std::move(rhs.value_.setType));
        break;
      }
      case Type::mapType:
      {
        set_mapType(std::move(rhs.value_.mapType));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    apache::thrift::clear(rhs);
  }

  TypeName(const TypeName& rhs);

  TypeName& operator=(TypeName&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        __fbthrift_clear();
        return *this;
      }
      case Type::boolType:
      {
        set_boolType(std::move(rhs.value_.boolType));
        break;
      }
      case Type::byteType:
      {
        set_byteType(std::move(rhs.value_.byteType));
        break;
      }
      case Type::i16Type:
      {
        set_i16Type(std::move(rhs.value_.i16Type));
        break;
      }
      case Type::i32Type:
      {
        set_i32Type(std::move(rhs.value_.i32Type));
        break;
      }
      case Type::i64Type:
      {
        set_i64Type(std::move(rhs.value_.i64Type));
        break;
      }
      case Type::floatType:
      {
        set_floatType(std::move(rhs.value_.floatType));
        break;
      }
      case Type::doubleType:
      {
        set_doubleType(std::move(rhs.value_.doubleType));
        break;
      }
      case Type::stringType:
      {
        set_stringType(std::move(rhs.value_.stringType));
        break;
      }
      case Type::binaryType:
      {
        set_binaryType(std::move(rhs.value_.binaryType));
        break;
      }
      case Type::enumType:
      {
        set_enumType(std::move(rhs.value_.enumType));
        break;
      }
      case Type::typedefType:
      {
        set_typedefType(std::move(rhs.value_.typedefType));
        break;
      }
      case Type::structType:
      {
        set_structType(std::move(rhs.value_.structType));
        break;
      }
      case Type::unionType:
      {
        set_unionType(std::move(rhs.value_.unionType));
        break;
      }
      case Type::exceptionType:
      {
        set_exceptionType(std::move(rhs.value_.exceptionType));
        break;
      }
      case Type::listType:
      {
        set_listType(std::move(rhs.value_.listType));
        break;
      }
      case Type::setType:
      {
        set_setType(std::move(rhs.value_.setType));
        break;
      }
      case Type::mapType:
      {
        set_mapType(std::move(rhs.value_.mapType));
        break;
      }
      default:
      {
        assert(false);
        __fbthrift_clear();
      }
    }
    apache::thrift::clear(rhs);
    return *this;
  }

  TypeName& operator=(const TypeName& rhs);

  ~TypeName();

  union storage_type {
    ::apache::thrift::type::Void boolType;
    ::apache::thrift::type::Void byteType;
    ::apache::thrift::type::Void i16Type;
    ::apache::thrift::type::Void i32Type;
    ::apache::thrift::type::Void i64Type;
    ::apache::thrift::type::Void floatType;
    ::apache::thrift::type::Void doubleType;
    ::apache::thrift::type::Void stringType;
    ::apache::thrift::type::Void binaryType;
    ::apache::thrift::type::TypeUri enumType;
    ::apache::thrift::type::TypeUri typedefType;
    ::apache::thrift::type::TypeUri structType;
    ::apache::thrift::type::TypeUri unionType;
    ::apache::thrift::type::TypeUri exceptionType;
    ::apache::thrift::type::Void listType;
    ::apache::thrift::type::Void setType;
    ::apache::thrift::type::Void mapType;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const TypeName&) const;
  bool operator<(const TypeName&) const;

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::Void& set_boolType(::apache::thrift::type::Void t = ::apache::thrift::type::Void()) {
    using T0 = ::apache::thrift::type::Void;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::boolType);
    ::new (std::addressof(value_.boolType)) T(t);
    return value_.boolType;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::Void& set_byteType(::apache::thrift::type::Void t = ::apache::thrift::type::Void()) {
    using T0 = ::apache::thrift::type::Void;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::byteType);
    ::new (std::addressof(value_.byteType)) T(t);
    return value_.byteType;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::Void& set_i16Type(::apache::thrift::type::Void t = ::apache::thrift::type::Void()) {
    using T0 = ::apache::thrift::type::Void;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::i16Type);
    ::new (std::addressof(value_.i16Type)) T(t);
    return value_.i16Type;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::Void& set_i32Type(::apache::thrift::type::Void t = ::apache::thrift::type::Void()) {
    using T0 = ::apache::thrift::type::Void;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::i32Type);
    ::new (std::addressof(value_.i32Type)) T(t);
    return value_.i32Type;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::Void& set_i64Type(::apache::thrift::type::Void t = ::apache::thrift::type::Void()) {
    using T0 = ::apache::thrift::type::Void;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::i64Type);
    ::new (std::addressof(value_.i64Type)) T(t);
    return value_.i64Type;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::Void& set_floatType(::apache::thrift::type::Void t = ::apache::thrift::type::Void()) {
    using T0 = ::apache::thrift::type::Void;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::floatType);
    ::new (std::addressof(value_.floatType)) T(t);
    return value_.floatType;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::Void& set_doubleType(::apache::thrift::type::Void t = ::apache::thrift::type::Void()) {
    using T0 = ::apache::thrift::type::Void;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::doubleType);
    ::new (std::addressof(value_.doubleType)) T(t);
    return value_.doubleType;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::Void& set_stringType(::apache::thrift::type::Void t = ::apache::thrift::type::Void()) {
    using T0 = ::apache::thrift::type::Void;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::stringType);
    ::new (std::addressof(value_.stringType)) T(t);
    return value_.stringType;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::Void& set_binaryType(::apache::thrift::type::Void t = ::apache::thrift::type::Void()) {
    using T0 = ::apache::thrift::type::Void;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::binaryType);
    ::new (std::addressof(value_.binaryType)) T(t);
    return value_.binaryType;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::TypeUri& set_enumType(::apache::thrift::type::TypeUri const &t) {
    using T0 = ::apache::thrift::type::TypeUri;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::enumType);
    ::new (std::addressof(value_.enumType)) T(t);
    return value_.enumType;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::TypeUri& set_enumType(::apache::thrift::type::TypeUri&& t) {
    using T0 = ::apache::thrift::type::TypeUri;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::enumType);
    ::new (std::addressof(value_.enumType)) T(std::move(t));
    return value_.enumType;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::type::TypeUri, T...>> ::apache::thrift::type::TypeUri& set_enumType(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::enumType);
    ::new (std::addressof(value_.enumType)) ::apache::thrift::type::TypeUri(std::forward<T>(t)...);
    return value_.enumType;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::TypeUri& set_typedefType(::apache::thrift::type::TypeUri const &t) {
    using T0 = ::apache::thrift::type::TypeUri;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::typedefType);
    ::new (std::addressof(value_.typedefType)) T(t);
    return value_.typedefType;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::TypeUri& set_typedefType(::apache::thrift::type::TypeUri&& t) {
    using T0 = ::apache::thrift::type::TypeUri;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::typedefType);
    ::new (std::addressof(value_.typedefType)) T(std::move(t));
    return value_.typedefType;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::type::TypeUri, T...>> ::apache::thrift::type::TypeUri& set_typedefType(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::typedefType);
    ::new (std::addressof(value_.typedefType)) ::apache::thrift::type::TypeUri(std::forward<T>(t)...);
    return value_.typedefType;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::TypeUri& set_structType(::apache::thrift::type::TypeUri const &t) {
    using T0 = ::apache::thrift::type::TypeUri;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::structType);
    ::new (std::addressof(value_.structType)) T(t);
    return value_.structType;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::TypeUri& set_structType(::apache::thrift::type::TypeUri&& t) {
    using T0 = ::apache::thrift::type::TypeUri;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::structType);
    ::new (std::addressof(value_.structType)) T(std::move(t));
    return value_.structType;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::type::TypeUri, T...>> ::apache::thrift::type::TypeUri& set_structType(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::structType);
    ::new (std::addressof(value_.structType)) ::apache::thrift::type::TypeUri(std::forward<T>(t)...);
    return value_.structType;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::TypeUri& set_unionType(::apache::thrift::type::TypeUri const &t) {
    using T0 = ::apache::thrift::type::TypeUri;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::unionType);
    ::new (std::addressof(value_.unionType)) T(t);
    return value_.unionType;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::TypeUri& set_unionType(::apache::thrift::type::TypeUri&& t) {
    using T0 = ::apache::thrift::type::TypeUri;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::unionType);
    ::new (std::addressof(value_.unionType)) T(std::move(t));
    return value_.unionType;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::type::TypeUri, T...>> ::apache::thrift::type::TypeUri& set_unionType(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::unionType);
    ::new (std::addressof(value_.unionType)) ::apache::thrift::type::TypeUri(std::forward<T>(t)...);
    return value_.unionType;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::TypeUri& set_exceptionType(::apache::thrift::type::TypeUri const &t) {
    using T0 = ::apache::thrift::type::TypeUri;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::exceptionType);
    ::new (std::addressof(value_.exceptionType)) T(t);
    return value_.exceptionType;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::TypeUri& set_exceptionType(::apache::thrift::type::TypeUri&& t) {
    using T0 = ::apache::thrift::type::TypeUri;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::exceptionType);
    ::new (std::addressof(value_.exceptionType)) T(std::move(t));
    return value_.exceptionType;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::type::TypeUri, T...>> ::apache::thrift::type::TypeUri& set_exceptionType(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::exceptionType);
    ::new (std::addressof(value_.exceptionType)) ::apache::thrift::type::TypeUri(std::forward<T>(t)...);
    return value_.exceptionType;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::Void& set_listType(::apache::thrift::type::Void t = ::apache::thrift::type::Void()) {
    using T0 = ::apache::thrift::type::Void;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::listType);
    ::new (std::addressof(value_.listType)) T(t);
    return value_.listType;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::Void& set_setType(::apache::thrift::type::Void t = ::apache::thrift::type::Void()) {
    using T0 = ::apache::thrift::type::Void;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::setType);
    ::new (std::addressof(value_.setType)) T(t);
    return value_.setType;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::apache::thrift::type::Void& set_mapType(::apache::thrift::type::Void t = ::apache::thrift::type::Void()) {
    using T0 = ::apache::thrift::type::Void;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::mapType);
    ::new (std::addressof(value_.mapType)) T(t);
    return value_.mapType;
  }


  ::apache::thrift::type::Void const& get_boolType() const {
    if (getType() != Type::boolType) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.boolType;
  }

  ::apache::thrift::type::Void const& get_byteType() const {
    if (getType() != Type::byteType) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.byteType;
  }

  ::apache::thrift::type::Void const& get_i16Type() const {
    if (getType() != Type::i16Type) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.i16Type;
  }

  ::apache::thrift::type::Void const& get_i32Type() const {
    if (getType() != Type::i32Type) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.i32Type;
  }

  ::apache::thrift::type::Void const& get_i64Type() const {
    if (getType() != Type::i64Type) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.i64Type;
  }

  ::apache::thrift::type::Void const& get_floatType() const {
    if (getType() != Type::floatType) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.floatType;
  }

  ::apache::thrift::type::Void const& get_doubleType() const {
    if (getType() != Type::doubleType) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.doubleType;
  }

  ::apache::thrift::type::Void const& get_stringType() const {
    if (getType() != Type::stringType) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.stringType;
  }

  ::apache::thrift::type::Void const& get_binaryType() const {
    if (getType() != Type::binaryType) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.binaryType;
  }

  ::apache::thrift::type::TypeUri const& get_enumType() const {
    if (getType() != Type::enumType) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.enumType;
  }

  ::apache::thrift::type::TypeUri const& get_typedefType() const {
    if (getType() != Type::typedefType) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.typedefType;
  }

  ::apache::thrift::type::TypeUri const& get_structType() const {
    if (getType() != Type::structType) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.structType;
  }

  ::apache::thrift::type::TypeUri const& get_unionType() const {
    if (getType() != Type::unionType) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.unionType;
  }

  ::apache::thrift::type::TypeUri const& get_exceptionType() const {
    if (getType() != Type::exceptionType) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.exceptionType;
  }

  ::apache::thrift::type::Void const& get_listType() const {
    if (getType() != Type::listType) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.listType;
  }

  ::apache::thrift::type::Void const& get_setType() const {
    if (getType() != Type::setType) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.setType;
  }

  ::apache::thrift::type::Void const& get_mapType() const {
    if (getType() != Type::mapType) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.mapType;
  }

  ::apache::thrift::type::Void& mutable_boolType() {
    assert(getType() == Type::boolType);
    return value_.boolType;
  }

  ::apache::thrift::type::Void& mutable_byteType() {
    assert(getType() == Type::byteType);
    return value_.byteType;
  }

  ::apache::thrift::type::Void& mutable_i16Type() {
    assert(getType() == Type::i16Type);
    return value_.i16Type;
  }

  ::apache::thrift::type::Void& mutable_i32Type() {
    assert(getType() == Type::i32Type);
    return value_.i32Type;
  }

  ::apache::thrift::type::Void& mutable_i64Type() {
    assert(getType() == Type::i64Type);
    return value_.i64Type;
  }

  ::apache::thrift::type::Void& mutable_floatType() {
    assert(getType() == Type::floatType);
    return value_.floatType;
  }

  ::apache::thrift::type::Void& mutable_doubleType() {
    assert(getType() == Type::doubleType);
    return value_.doubleType;
  }

  ::apache::thrift::type::Void& mutable_stringType() {
    assert(getType() == Type::stringType);
    return value_.stringType;
  }

  ::apache::thrift::type::Void& mutable_binaryType() {
    assert(getType() == Type::binaryType);
    return value_.binaryType;
  }

  ::apache::thrift::type::TypeUri& mutable_enumType() {
    assert(getType() == Type::enumType);
    return value_.enumType;
  }

  ::apache::thrift::type::TypeUri& mutable_typedefType() {
    assert(getType() == Type::typedefType);
    return value_.typedefType;
  }

  ::apache::thrift::type::TypeUri& mutable_structType() {
    assert(getType() == Type::structType);
    return value_.structType;
  }

  ::apache::thrift::type::TypeUri& mutable_unionType() {
    assert(getType() == Type::unionType);
    return value_.unionType;
  }

  ::apache::thrift::type::TypeUri& mutable_exceptionType() {
    assert(getType() == Type::exceptionType);
    return value_.exceptionType;
  }

  ::apache::thrift::type::Void& mutable_listType() {
    assert(getType() == Type::listType);
    return value_.listType;
  }

  ::apache::thrift::type::Void& mutable_setType() {
    assert(getType() == Type::setType);
    return value_.setType;
  }

  ::apache::thrift::type::Void& mutable_mapType() {
    assert(getType() == Type::mapType);
    return value_.mapType;
  }

  ::apache::thrift::type::Void move_boolType() {
    assert(getType() == Type::boolType);
    return std::move(value_.boolType);
  }

  ::apache::thrift::type::Void move_byteType() {
    assert(getType() == Type::byteType);
    return std::move(value_.byteType);
  }

  ::apache::thrift::type::Void move_i16Type() {
    assert(getType() == Type::i16Type);
    return std::move(value_.i16Type);
  }

  ::apache::thrift::type::Void move_i32Type() {
    assert(getType() == Type::i32Type);
    return std::move(value_.i32Type);
  }

  ::apache::thrift::type::Void move_i64Type() {
    assert(getType() == Type::i64Type);
    return std::move(value_.i64Type);
  }

  ::apache::thrift::type::Void move_floatType() {
    assert(getType() == Type::floatType);
    return std::move(value_.floatType);
  }

  ::apache::thrift::type::Void move_doubleType() {
    assert(getType() == Type::doubleType);
    return std::move(value_.doubleType);
  }

  ::apache::thrift::type::Void move_stringType() {
    assert(getType() == Type::stringType);
    return std::move(value_.stringType);
  }

  ::apache::thrift::type::Void move_binaryType() {
    assert(getType() == Type::binaryType);
    return std::move(value_.binaryType);
  }

  ::apache::thrift::type::TypeUri move_enumType() {
    assert(getType() == Type::enumType);
    return std::move(value_.enumType);
  }

  ::apache::thrift::type::TypeUri move_typedefType() {
    assert(getType() == Type::typedefType);
    return std::move(value_.typedefType);
  }

  ::apache::thrift::type::TypeUri move_structType() {
    assert(getType() == Type::structType);
    return std::move(value_.structType);
  }

  ::apache::thrift::type::TypeUri move_unionType() {
    assert(getType() == Type::unionType);
    return std::move(value_.unionType);
  }

  ::apache::thrift::type::TypeUri move_exceptionType() {
    assert(getType() == Type::exceptionType);
    return std::move(value_.exceptionType);
  }

  ::apache::thrift::type::Void move_listType() {
    assert(getType() == Type::listType);
    return std::move(value_.listType);
  }

  ::apache::thrift::type::Void move_setType() {
    assert(getType() == Type::setType);
    return std::move(value_.setType);
  }

  ::apache::thrift::type::Void move_mapType() {
    assert(getType() == Type::mapType);
    return std::move(value_.mapType);
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> boolType_ref() const& {
    return {value_.boolType, type_, folly::to_underlying(Type::boolType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> boolType_ref() const&& {
    return {std::move(value_.boolType), type_, folly::to_underlying(Type::boolType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> boolType_ref() & {
    return {value_.boolType, type_, folly::to_underlying(Type::boolType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> boolType_ref() && {
    return {std::move(value_.boolType), type_, folly::to_underlying(Type::boolType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> byteType_ref() const& {
    return {value_.byteType, type_, folly::to_underlying(Type::byteType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> byteType_ref() const&& {
    return {std::move(value_.byteType), type_, folly::to_underlying(Type::byteType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> byteType_ref() & {
    return {value_.byteType, type_, folly::to_underlying(Type::byteType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> byteType_ref() && {
    return {std::move(value_.byteType), type_, folly::to_underlying(Type::byteType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> i16Type_ref() const& {
    return {value_.i16Type, type_, folly::to_underlying(Type::i16Type), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> i16Type_ref() const&& {
    return {std::move(value_.i16Type), type_, folly::to_underlying(Type::i16Type), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> i16Type_ref() & {
    return {value_.i16Type, type_, folly::to_underlying(Type::i16Type), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> i16Type_ref() && {
    return {std::move(value_.i16Type), type_, folly::to_underlying(Type::i16Type), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> i32Type_ref() const& {
    return {value_.i32Type, type_, folly::to_underlying(Type::i32Type), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> i32Type_ref() const&& {
    return {std::move(value_.i32Type), type_, folly::to_underlying(Type::i32Type), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> i32Type_ref() & {
    return {value_.i32Type, type_, folly::to_underlying(Type::i32Type), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> i32Type_ref() && {
    return {std::move(value_.i32Type), type_, folly::to_underlying(Type::i32Type), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> i64Type_ref() const& {
    return {value_.i64Type, type_, folly::to_underlying(Type::i64Type), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> i64Type_ref() const&& {
    return {std::move(value_.i64Type), type_, folly::to_underlying(Type::i64Type), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> i64Type_ref() & {
    return {value_.i64Type, type_, folly::to_underlying(Type::i64Type), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> i64Type_ref() && {
    return {std::move(value_.i64Type), type_, folly::to_underlying(Type::i64Type), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> floatType_ref() const& {
    return {value_.floatType, type_, folly::to_underlying(Type::floatType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> floatType_ref() const&& {
    return {std::move(value_.floatType), type_, folly::to_underlying(Type::floatType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> floatType_ref() & {
    return {value_.floatType, type_, folly::to_underlying(Type::floatType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> floatType_ref() && {
    return {std::move(value_.floatType), type_, folly::to_underlying(Type::floatType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> doubleType_ref() const& {
    return {value_.doubleType, type_, folly::to_underlying(Type::doubleType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> doubleType_ref() const&& {
    return {std::move(value_.doubleType), type_, folly::to_underlying(Type::doubleType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> doubleType_ref() & {
    return {value_.doubleType, type_, folly::to_underlying(Type::doubleType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> doubleType_ref() && {
    return {std::move(value_.doubleType), type_, folly::to_underlying(Type::doubleType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> stringType_ref() const& {
    return {value_.stringType, type_, folly::to_underlying(Type::stringType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> stringType_ref() const&& {
    return {std::move(value_.stringType), type_, folly::to_underlying(Type::stringType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> stringType_ref() & {
    return {value_.stringType, type_, folly::to_underlying(Type::stringType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> stringType_ref() && {
    return {std::move(value_.stringType), type_, folly::to_underlying(Type::stringType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> binaryType_ref() const& {
    return {value_.binaryType, type_, folly::to_underlying(Type::binaryType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> binaryType_ref() const&& {
    return {std::move(value_.binaryType), type_, folly::to_underlying(Type::binaryType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> binaryType_ref() & {
    return {value_.binaryType, type_, folly::to_underlying(Type::binaryType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> binaryType_ref() && {
    return {std::move(value_.binaryType), type_, folly::to_underlying(Type::binaryType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> enumType_ref() const& {
    return {value_.enumType, type_, folly::to_underlying(Type::enumType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> enumType_ref() const&& {
    return {std::move(value_.enumType), type_, folly::to_underlying(Type::enumType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> enumType_ref() & {
    return {value_.enumType, type_, folly::to_underlying(Type::enumType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> enumType_ref() && {
    return {std::move(value_.enumType), type_, folly::to_underlying(Type::enumType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> typedefType_ref() const& {
    return {value_.typedefType, type_, folly::to_underlying(Type::typedefType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> typedefType_ref() const&& {
    return {std::move(value_.typedefType), type_, folly::to_underlying(Type::typedefType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> typedefType_ref() & {
    return {value_.typedefType, type_, folly::to_underlying(Type::typedefType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> typedefType_ref() && {
    return {std::move(value_.typedefType), type_, folly::to_underlying(Type::typedefType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> structType_ref() const& {
    return {value_.structType, type_, folly::to_underlying(Type::structType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> structType_ref() const&& {
    return {std::move(value_.structType), type_, folly::to_underlying(Type::structType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> structType_ref() & {
    return {value_.structType, type_, folly::to_underlying(Type::structType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> structType_ref() && {
    return {std::move(value_.structType), type_, folly::to_underlying(Type::structType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> unionType_ref() const& {
    return {value_.unionType, type_, folly::to_underlying(Type::unionType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> unionType_ref() const&& {
    return {std::move(value_.unionType), type_, folly::to_underlying(Type::unionType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> unionType_ref() & {
    return {value_.unionType, type_, folly::to_underlying(Type::unionType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> unionType_ref() && {
    return {std::move(value_.unionType), type_, folly::to_underlying(Type::unionType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> exceptionType_ref() const& {
    return {value_.exceptionType, type_, folly::to_underlying(Type::exceptionType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> exceptionType_ref() const&& {
    return {std::move(value_.exceptionType), type_, folly::to_underlying(Type::exceptionType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> exceptionType_ref() & {
    return {value_.exceptionType, type_, folly::to_underlying(Type::exceptionType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::TypeUri>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> exceptionType_ref() && {
    return {std::move(value_.exceptionType), type_, folly::to_underlying(Type::exceptionType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> listType_ref() const& {
    return {value_.listType, type_, folly::to_underlying(Type::listType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> listType_ref() const&& {
    return {std::move(value_.listType), type_, folly::to_underlying(Type::listType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> listType_ref() & {
    return {value_.listType, type_, folly::to_underlying(Type::listType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> listType_ref() && {
    return {std::move(value_.listType), type_, folly::to_underlying(Type::listType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> setType_ref() const& {
    return {value_.setType, type_, folly::to_underlying(Type::setType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> setType_ref() const&& {
    return {std::move(value_.setType), type_, folly::to_underlying(Type::setType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> setType_ref() & {
    return {value_.setType, type_, folly::to_underlying(Type::setType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> setType_ref() && {
    return {std::move(value_.setType), type_, folly::to_underlying(Type::setType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> mapType_ref() const& {
    return {value_.mapType, type_, folly::to_underlying(Type::mapType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> mapType_ref() const&& {
    return {std::move(value_.mapType), type_, folly::to_underlying(Type::mapType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> mapType_ref() & {
    return {value_.mapType, type_, folly::to_underlying(Type::mapType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::type::Void>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> mapType_ref() && {
    return {std::move(value_.mapType), type_, folly::to_underlying(Type::mapType), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<TypeName>;
  friend void swap(TypeName& a, TypeName& b);
};

template <class Protocol_>
unsigned long TypeName::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


} // namespace apache::thrift::type

namespace apache { namespace thrift {

template <> struct TEnumDataStorage<::apache::thrift::type::TypeUri::Type>;

template <> struct TEnumTraits<::apache::thrift::type::TypeUri::Type> {
  using type = ::apache::thrift::type::TypeUri::Type;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }
};

template <> struct TEnumDataStorage<::apache::thrift::type::TypeName::Type>;

template <> struct TEnumTraits<::apache::thrift::type::TypeName::Type> {
  using type = ::apache::thrift::type::TypeName::Type;

  static constexpr std::size_t const size = 17;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }
};
}} // apache::thrift
